<!DOCTYPE html>
<html lang="en">
<head>  
    <meta charset="UTF-8">
    <title>CoffeeCodeCoffee</title>
    <link rel="icon" href="../Images/coffeecodecoffee.png">
    <link rel="stylesheet" type="text/css" href="../style.css">
    <link href="https://fonts.googleapis.com/css?family=Hind&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Hind+Madurai:400,700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Inter&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Yellowtail&display=swap" rel="stylesheet">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
</head>
    
    
<body>
    <!--%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    Header
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%-->
    
    <header>
        <div class="logo">
            <img class="logoImage" src="../Images/coffeecodecoffee.png" alt="CoffeeCodeCoffee Logo">
        </div>
        
        <div class="name">
            JUSTIN LEONG
        </div>
        
        <!--%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        Navigation Bar
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%-->
        <div class="navbar">
            <!--Home-->
            <div class="dropdown" id="dropdownHome">
                <a class="mainHeader" id="headerHome" href="../">Home</a>
            </div>
            
            <!--Data Structures-->
            <div class="dropdown" id="dropdownDataStructures">
                <a class="mainHeader" id="headerDataStructures">Data Structures</a>
                
                <div class="dropdownContent" id="dropdownContentDataStructures">
                    <a href="/arrays/">Arrays</a>
                    <a href="/linkedlists/">LinkedLists</a>
                    <a href="/stacksAndQueues/">Stacks and Queues</a>
                    <a href="/trees/">Trees</a>
                    <a href="/graphs/">Graphs</a>
                    <a href="/hashMap/">HashMaps</a>
                </div>
            </div>
            
            <!--Algorithms-->
            <div class="dropdown" id="dropdownAlgorithms">
                <a class="mainHeader" id="headerAlgorithms">Algorithms</a>
                
                <div class="dropdownContent" id="dropdownContentAlgorithms">
                    <a href="/bubbleSort/">Bubble Sort</a>
                    <a href="/mergeSort/">Merge Sort</a>
                    <a href="/quickSort/">Quick Sort</a>
                    <a href="/dfs/">Graph: DFS</a>
                    <a href="/bfs/">Graph: BFS</a>
                    <a href="/binarySearch/">Binary Search</a>
                </div>
            </div>
            
            <!--Projects-->
            <div class="dropdown" id="dropdownProjects">
                <a class="mainHeader" id="headerProjects">Projects</a>
                
                <div class="dropdownContent" id="dropdownContentProjects">
                    <a href="/projects/sortingVisualizer/">Sorting Visualizer</a>
                </div>
            </div>
        </div>
    </header>

    <!--%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    Main Content Section
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%-->
    <div class=fullScreen>
        
        <!--%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        Breadth First Search Definition Section
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%-->
        <div class="sectionDivider">
            <h1 class="headerCenter">Breadth First Search (BFS)</h1>
            
            <div class="paragraph">
                Breadth First Search (BFS) is a searching algorithm that explores the nodes closest to the starting point before expanding outwards and exploring the rest of the nodes in the graph. BFS is often described as the search wide before deep algorithm because we stay as close to the starting point as possible before traversing deep into the graph. In order to stay close to the starting point, this algorithm requires a queue data structure to keep track of which node should be next in line to be searched. As the search expands outwards, the nodes connected to the current search node are added to the end of the queue until all the nodes in the graph have been visited.
            </div>
            
            <div class="paragraph noTopPadding">
                The best way to understand BFS is through a visual example which we will be applying on the following tree. We will be using a tree since it allows us to better visualize BFS than in a graph that contains cycles.
            </div>
            
            <div class="sectionImage">
                <img src="../Images/Algorithms/BFS/bfs_nhl_players.png">
            </div>
            
            <div class="paragraph">
                 This tree contains the names of the top NHL players where each level represents the skill level of the player. We want to traverse the tree using the BFS algorithm, starting at the root (top player), to list out all the players in the order of their skill level. 
            </div>
            
            <div class="paragraph noTopPadding">
                 BFS would start at Connor McDavid then search for the next best players by seeing who Connor McDavid is linked to. From looking at the tree, McDavid is connected to Sidney Crosby, Nikita Kucherov, and Alex Ovechkin. We would add these three names in that order to our queue so we know who to check next. Since Crosby is next in our queue, we would traverse to him and add all the players connected to him to the end of the queue. Kucherov is next in the queue after Crosby so we would traverse to him and add all his connections to the end of the queue. We continue to repeat this process until we have added all of the players in the tree to the queue and have iterated through each of the players in the queue. 
            </div>
            
            <div class="paragraph noTopPadding">
                 The output of this BFS traversal would look like this:
            </div>
            
            <div class="sectionImage">
                <img src="../Images/Algorithms/BFS/bfs_nhl_players_output.png">
            </div>
            
            <div class="paragraph">
                 The visual step by step BFS traversal of this tree would look like the following with the queue items at each stage. Note that when we traverse to the next player in the front of the queue we remove them from the queue list. 
            </div>
            
            <div class="sectionImage">
                <img src="../Images/Algorithms/BFS/bfs_nhl_example1.png">
            </div>
            
            <div class="sectionImage">
                <img src="../Images/Algorithms/BFS/bfs_nhl_example2.png">
            </div>
            
            <div class="sectionImage">
                <img src="../Images/Algorithms/BFS/bfs_nhl_example3.png">
            </div>
            
            <div class="sectionImage">
                <img src="../Images/Algorithms/BFS/bfs_nhl_example4.png">
            </div>
            
            <div class="sectionImage">
                <img src="../Images/Algorithms/BFS/bfs_nhl_example5.png">
            </div>
            
            <div class="sectionImage">
                <img src="../Images/Algorithms/BFS/bfs_nhl_example6.png">
            </div>
            
            <div class="sectionImage">
                <img src="../Images/Algorithms/BFS/bfs_nhl_example7.png">
            </div>
            
            <div class="sectionImage">
                <img src="../Images/Algorithms/BFS/bfs_nhl_example8.png">
            </div>
            
            <div class="sectionImage">
                <img src="../Images/Algorithms/BFS/bfs_nhl_example9.png">
            </div>
            
            <div class="sectionImage">
                <img src="../Images/Algorithms/BFS/bfs_nhl_example10.png">
            </div>
            
            <div class="sectionImage">
                <img src="../Images/Algorithms/BFS/bfs_nhl_example11.png">
            </div>
        </div>
        
        <!--%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        Code Implementation Section
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%-->
        <div class="sectionDivider">
            <h1 class="headerCenter">Code Implementation</h1>
            
            <div class="paragraph">
                Similar to DFS, the BFS algorithm can be implemented both iteratively and recursively. The following code implementation will be done iteratively, however it can be slightly modified to become recursive. Note that this algorithm will built off of the Graph data structure and a good understanding of the Graph data structure is required before proceeding.
            </div>
            
            <div class="paragraph noTopPadding">
                To begin the implementation of BFS, we will create the function called traverseGraphBFS() with a single parameter called 'start'. The start parameter will be the value of the node that we want our traversal to begin at. The following functions are tailored towards applying BFS on a graph that contains integers as the node values. The data type can simply be changed to fit the structure of the graph you want to apply BFS on.
            </div>
            
            <div class="code codeWideFinal">
                <p class="codePurple">public void</p> traverseGraphBFS(<p class="codePurple">int</p> start){
                <br><br>
                }
            </div>
            
            <div class="paragraph">
                The next step is to get the node reference from our nodeLookup HashMap and determine if this node exists in our graph. If the start node doesn't exist in the graph we can immediately exit the function. Note that the nodeLookup HashMap is part of the Graph data structure, if you are unfamiliar with this concept check out my page on how to construct the Graph data structure from scratch before continuing. 
            </div>
            
            <div class="code codeWideFinal">
                <p class="codePurple">public void</p> traverseGraphBFS(<p class="codePurple">int</p> start){
                <br>
                <p class="indent1">Node startNode = nodeLookup.get(start);</p>
                <br><br>
                <p class="indent1 codePurple">if</p>(startNode == <p class="codePurple">null</p>){
                <br>
                <p class="indent2 codePurple">return</p>;
                <br>
                <p class="indent1">}</p>
                <br>
                }
            </div>
            
            <div class="paragraph">
                Similar to DFS, we will need a data structure to keep track of the nodes we have already visited. We can use a HashSet called 'visited' to keep track of these nodes. Another data structure that we will need is a queue, as we recall this queue will hold the order of the nodes that we traverse next. We can use a LinkedList to represent this queue.
            </div>
            
            <div class="code codeWideFinal">
                <p class="codePurple">public void</p> traverseGraphBFS(<p class="codePurple">int</p> start){
                <br>
                <p class="indent1">Node startNode = nodeLookup.get(start);</p>
                <br><br>
                <p class="indent1 codePurple">if</p>(startNode == <p class="codePurple">null</p>){
                <br>
                <p class="indent2 codePurple">return</p>;
                <br>
                <p class="indent1">}</p>
                <br><br>
                <p class="indent1">HashSet&lt;Node&gt; visited = </p> <p class="codePurple">new</p> HashSet&lt;Node&gt;();
                <br>
                <p class="indent1">LinkedList&lt;Node&gt; queue = </p> <p class="codePurple">new</p> LinkedList&lt;Node&gt;();
                <br>
                }
            </div>
            
            <div class="paragraph">
                Now that we have created the queue, we need to add the first item to the queue to begin the BFS traversal. This will be the startNode that we had initialized earlier.
            </div>
            
           <div class="code codeWideFinal">
                <p class="codePurple">public void</p> traverseGraphBFS(<p class="codePurple">int</p> start){
                <br>
                <p class="indent1">Node startNode = nodeLookup.get(start);</p>
                <br><br>
                <p class="indent1 codePurple">if</p>(startNode == <p class="codePurple">null</p>){
                <br>
                <p class="indent2 codePurple">return</p>;
                <br>
                <p class="indent1">}</p>
                <br><br>
                <p class="indent1">HashSet&lt;Node&gt; visited = </p> <p class="codePurple">new</p> HashSet&lt;Node&gt;();
                <br>
                <p class="indent1">LinkedList&lt;Node&gt; queue = </p> <p class="codePurple">new</p> LinkedList&lt;Node&gt;();
                <br><br>
                <p class="indent1">queue.add(startNode);</p>
                <br>
                }
            </div>
            
            <div class="paragraph">
                We can now begin writing the actual BFS logic. Since this is an iterative solution, we need to consider what the terminating case should be. We know that when we traverse a node we take the next node out of the start of the queue that we want to visit next. Thus our algorithm needs to run as long as there is an item in the queue. Therefore we can create a while loop where we continue to loop until we have exhausted all the items in our queue. 
            </div>
            
            <div class="code codeWideFinal">
                <p class="codePurple">public void</p> traverseGraphBFS(<p class="codePurple">int</p> start){
                <br>
                <p class="indent1">Node startNode = nodeLookup.get(start);</p>
                <br><br>
                <p class="indent1 codePurple">if</p>(startNode == <p class="codePurple">null</p>){
                <br>
                <p class="indent2 codePurple">return</p>;
                <br>
                <p class="indent1">}</p>
                <br><br>
                <p class="indent1">HashSet&lt;Node&gt; visited = </p> <p class="codePurple">new</p> HashSet&lt;Node&gt;();
                <br>
                <p class="indent1">LinkedList&lt;Node&gt; queue = </p> <p class="codePurple">new</p> LinkedList&lt;Node&gt;();
                <br><br>
                <p class="indent1">queue.add(startNode);</p>
                <br><br>
                <p class="indent1 codePurple">while</p>(!queue.isEmpty()){
                <br>
                <p class="indent2 codePurple"></p>
                <br>
                <p class="indent1">}</p>
                <br>
                }
            </div>
            
            <div class="paragraph">
                Now if the queue is not empty, we can pop the next item in the queue and check if we have visited this node before. If we have visited this node before, then we continue the loop and pop the next item from the list. We can determine if we have been to a node before by checking if it exists in the visited HashSet data structure. If we have not been to this node before, then we will add this node to the visited set and print the value of the node to the console.
            </div>
            
            <div class="code codeWideFinal">
                <p class="codePurple">public void</p> traverseGraphBFS(<p class="codePurple">int</p> start){
                <br>
                <p class="indent1">Node startNode = nodeLookup.get(start);</p>
                <br><br>
                <p class="indent1 codePurple">if</p>(startNode == <p class="codePurple">null</p>){
                <br>
                <p class="indent2 codePurple">return</p>;
                <br>
                <p class="indent1">}</p>
                <br><br>
                <p class="indent1">HashSet&lt;Node&gt; visited = </p> <p class="codePurple">new</p> HashSet&lt;Node&gt;();
                <br>
                <p class="indent1">LinkedList&lt;Node&gt; queue = </p> <p class="codePurple">new</p> LinkedList&lt;Node&gt;();
                <br><br>
                <p class="indent1">queue.add(startNode);</p>
                <br><br>
                <p class="indent1 codePurple">while</p>(!queue.isEmpty()){
                <br>
                <p class="indent2">Node currentNode = queue.pop();</p>
                <br><br>
                <p class="indent2 codePurple">if</p>(visited.contains(currentNode)){
                <br>
                <p class="indent3 codePurple">continue</p>;
                <br>
                <p class="indent2">}</p>
                <br><br>
                <p class="indent2">visited.add(currentNode);</p>
                <br><br>
                <p class="indent2">System.out.println(currentNode.data);</p>
                <br>
                <p class="indent1">}</p>
                <br>
                }
            </div>
            
            <div class="paragraph noTopPadding">
                The last step is to add the child/adjacent nodes of the current node to the end of the queue. This can be perform with a for each loop on the current node's adjacent LinkedList. The adjacent list is part of the Graph data structure and contains all the node connections from a particular node.
            </div>
            
            <div class="code codeWideFinal">
                <p class="codePurple">public void</p> traverseGraphBFS(<p class="codePurple">int</p> start){
                <br>
                <p class="indent1">Node startNode = nodeLookup.get(start);</p>
                <br><br>
                <p class="indent1 codePurple">if</p>(startNode == <p class="codePurple">null</p>){
                <br>
                <p class="indent2 codePurple">return</p>;
                <br>
                <p class="indent1">}</p>
                <br><br>
                <p class="indent1">HashSet&lt;Node&gt; visited = </p> <p class="codePurple">new</p> HashSet&lt;Node&gt;();
                <br>
                <p class="indent1">LinkedList&lt;Node&gt; queue = </p> <p class="codePurple">new</p> LinkedList&lt;Node&gt;();
                <br><br>
                <p class="indent1">queue.add(startNode);</p>
                <br><br>
                <p class="indent1 codePurple">while</p>(!queue.isEmpty()){
                <br>
                <p class="indent2">Node currentNode = queue.pop();</p>
                <br><br>
                <p class="indent2 codePurple">if</p>(visited.contains(currentNode)){
                <br>
                <p class="indent3 codePurple">continue</p>;
                <br>
                <p class="indent2">}</p>
                <br><br>
                <p class="indent2">visited.add(currentNode);</p>
                <br><br>
                <p class="indent2">System.out.println(currentNode.data);</p>
                <br><br>
                <p class="indent2 codePurple">for</p>(Node adj : currentNode.adjacent){
                <br>
                <p class="indent3">queue.add(adj);</p>
                <br>
                <p class="indent2">}</p>
                <br>
                <p class="indent1">}</p>
                <br>
                }
            </div>
            
            <div class="paragraph noTopPadding">
                This is the completed BFS algorithm which traverses all of the nodes closes to the starting node before expanding outwards into the graph. The key concept to remember in BFS is that the traversal explores the nodes closes to the start position before expanding outwards. 
            </div>
        </div>
        
    </div>
    
    <!--%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    Footer
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%-->
    <footer>
        <section class="footerSocial">
            <ul class="footerSocialList">
                <div class="footerLogo">
                    <img class="logoImage" src="../Images/tilde.png" alt="CoffeeCodeCoffee Logo">
                </div>
                
                <div class="footerLogo">
                    <img class="logoImage" src="../Images/coffeecodecoffee.png" alt="CoffeeCodeCoffee Logo">
                </div>

                <div class="footerLogo">
                    <img class="logoImage" src="../Images/coffeecodecoffee.png" alt="CoffeeCodeCoffee Logo">
                </div>

                <div class="footerLogo">
                    <img class="logoImage" src="../Images/coffeecodecoffee.png" alt="CoffeeCodeCoffee Logo">
                </div>

                <div class="footerLogo">
                    <img class="logoImage" src="../Images/coffeecodecoffee.png" alt="CoffeeCodeCoffee Logo">
                </div>

                <div class="footerLogo">
                    <img class="logoImage" src="../Images/coffeecodecoffee.png" alt="CoffeeCodeCoffee Logo">
                </div>

                <div class="footerLogo">
                    <img class="logoImage" src="../Images/coffeecodecoffee.png" alt="CoffeeCodeCoffee Logo">
                </div>
                
                <div class="footerLogo">
                    <img class="logoImage" src="../Images/tilde.png" alt="CoffeeCodeCoffee Logo">
                </div>
            </ul>
        </section>
    </footer>
	
</body>
</html>
